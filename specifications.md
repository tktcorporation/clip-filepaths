Electronアプリで複数画像を同時にコピー＆ペーストする方法 – 調査報告

背景と目的

Electronベースのアプリケーションで、複数の画像を選択して一括コピーし、Discordなどのチャットアプリに貼り付けると、エクスプローラーやFinderからコピーした場合と同様に複数の画像ファイルとして認識される動作を実現したいと考えています。標準のElectronのclipboardモジュールでは、テキストや単一の画像コピーは可能ですが、複数ファイルのパス情報を一度にクリップボードに設定することはできません ￼。そのため、ElectronアプリからOSネイティブのクリップボード操作を行うカスタムモジュールが必要になります。ここでは、新たにRust製のネイティブNPMライブラリを作成することを視野に、各OSでの複数ファイルコピーの仕組みと、Electron＋Rustで実装するための技術的検討結果を報告します。

OS別: 複数ファイルをクリップボードにコピーする仕組み

各プラットフォームごとに、複数のファイルパス（画像ファイル）をクリップボードにコピーするためのネイティブ機構が異なります。以下にWindows、macOS、Linuxそれぞれの方法をまとめます。
	•	Windowsの場合: Windowsではエクスプローラーでファイルをコピーすると、クリップボードにCF_HDROPという特殊なフォーマットでファイル名リストが格納されます ￼ ￼。CF_HDROPはグローバルメモリブロック中にDROPFILES構造体と複数のパス文字列をダブルnull区切りで含む形式です。例えばC:\temp1.txtとC:\temp2.txtの2つのファイルをコピーすると、メモリ上には"C:\temp1.txt\0C:\temp2.txt\0\0"（\0はnull文字）というように連続したパス列が格納されます ￼。アプリケーション側はWin32 APIのOpenClipboard → EmptyClipboard → SetClipboardData(CF_HDROP, hGlobal)でこのデータを設定できます ￼。DROPFILES構造体のpFilesにファイル名配列へのオフセットを指定し、fWideをTRUEにしてUNICODE文字列とすることで、複数のファイルパスを一括でクリップボードに登録できます ￼ ￼。Windows Shellはこの形式を認識し、Discordなどのアプリで貼り付けると個別のファイルとして処理されます。必要に応じて、クリップボードにはコピー/切り取りの区別用にCFSTR_PREFERREDDROPEFFECT（コピーか移動か）などの追加フォーマットも設定できますが、単にコピーとして貼り付けさせる場合はCF_HDROPだけで十分です。
	•	macOSの場合: macOSのFinderでファイルをコピーすると、クリップボード（NSPasteboard）にファイルURLの配列が保持されます。プログラムから複数ファイルをコピーするには、CocoaのNSPasteboardクラスを使い、一般ペーストボードに対してNSPasteboardTypeFileURL型（または10.6以前ではNSFilenamesPboardType）のエントリを設定します。具体的には、NSURLオブジェクトの配列を用意し、[pasteboard writeObjects: arrayOfFileURLs]とすることで複数のファイルパスを一度に書き込めます ￼ ￼。たとえばAppleScript経由になりますが、下記のコードは複数ファイルパスのリストをNSURLに変換し、NSPasteboard.generalPasteboard()にwriteObjectsしている例です ￼ ￼。これによりFinderからのコピーと同じ状態になり、対応アプリでは複数ファイルとして貼り付け可能です。
	•	Linuxの場合: Linuxのデスクトップ環境では、クリップボードに複数ファイルの参照をコピーする際、MIMEタイプtext/uri-listを用いてファイルのURI一覧を設定する方法が一般的です。例えばX11環境では、clipboard選択にfile://...形式のURIを改行区切りで含むtext/uri-listデータをセットします。GNOMEのファイルマネージャ（Nautilus）等もこの形式を使用しており、コピーされたファイルはペースト先アプリで複数ファイルとして認識されます ￼。Wayland環境でもwl-copyコマンドでtext/uri-listを指定して同様のコピーが可能です ￼。実装的には、X11のXSetSelectionOwnerを使って所有権を取得し、TARGETS問い合わせに対してtext/uri-listを提供するなど低レベル処理が必要ですが、GTKやQtの高位APIではファイルリストのコピー機能が用意されています。Linuxでは対応するクリップボードライブラリ（例：GtkClipboardなど）を利用するか、コマンドラインツール（xclipやwl-copy）を呼び出す方法が考えられます。

以上をまとめると、WindowsではCF_HDROP形式、macOSではNSURL配列、Linuxではtext/uri-listという形式で、それぞれ複数ファイルのコピーが実現されています。下表に各OSの方式を整理します：

OS	複数ファイルコピーの形式	備考
Windows	CF_HDROP（DROPFILES構造体＋パスの列挙）	Win32 APIで実装可能 ￼ ￼。エクスプローラーのコピーと同様
macOS	NSPasteboard上にNSURLの配列（NSPasteboardTypeFileURL）	Cocoaで実装。Finderのコピーと同様 ￼ ￼
Linux	text/uri-list MIMEでファイルURIを列挙	X11/Waylandで利用 ￼。ファイルマネージャのコピーと同様

実装方針の検討：Electronから複数ファイルをコピーするには

上記のネイティブ機構を踏まえ、Electronアプリからこれらを利用する方法を検討します。大きく分けて次の選択肢があります。
	1.	Electronの標準機能のみで実装:  前述の通り、Electronのclipboardモジュールはテキストや画像データは扱えますが、複数ファイルのパスリストを書き込むAPIは用意されていません ￼。例えばclipboard.writeBuffer('NSFilenamesPboardType', ...)のような低レベル操作はサポートされず、実質この案は困難です。したがって標準機能のみでの実現は断念し、他の方法を取る必要があります。
	2.	外部コマンド/スクリプトを利用: Electron（Node.js）から各OSのクリップボード操作コマンドを呼び出す方法です。例えばWindowsではPowerShellのSet-Clipboard -LiteralPathコマンドを使うとファイルパス配列をクリップボードにコピーできます ￼。macOSではosascriptでAppleScriptを実行し、上記のNSURL配列コピーを行うことができます ￼。Linuxではxclipやwl-copyコマンドを利用してtext/uri-listを設定できます。しかし、この方法は各プラットフォームごとに依存する外部ツールが必要で、ユーザ環境にそれらがインストール・使用可能であることが前提となります。またプロセス呼び出しのオーバーヘッドもあるため、アプリに組み込むには煩雑です。簡易な実験用途としては有効ですが、製品レベルでは管理やエラーハンドリングが難しくなる可能性があります。
	3.	ネイティブアドオン（C++またはRust）の作成: Node.jsのネイティブアドオン機能を用いて、C++もしくはRustで各OSのAPIを呼び出すモジュールを実装する方法です。これなら外部ツールに頼らず、直接OSのClipboard APIを操作できます。C++で実装する場合、Electron（Node.js）向けにはN-APIもしくはNode.jsのアドオンAPI (nanやnode-addon-api)を利用できます。同様にRustでもN-APIバインディングを使ったライブラリが整備されており、Rustで安全に実装してNode.jsから呼び出すことが可能です ￼ ￼。この方法のメリットは、単一のNPMパッケージとしてElectronアプリに組み込みやすく、パフォーマンスも高いことです。デメリットはビルドにネイティブツールチェーンが必要な点ですが、後述する自動ビルド/配布の仕組みを整えればユーザの負担を軽減できます。現代的なElectronネイティブモジュールはRustで書かれる例も増えており、メンテナンス性も良好と考えられます。

以上を比較すると、最終的に3のネイティブアドオン方式を採用するのが望ましいと判断します。理由は、動作の確実さとクロスプラットフォーム対応、そしてElectron/Node.jsとの親和性です。TypeScript（Node.js）から直接呼び出せるNPMモジュールの形にすれば、アプリ開発者はあまり内部実装を意識せず機能を利用できます。今回はRust製のネイティブモジュールとして実装する前提で、技術スタックやプロジェクト構成、ビルド方法を詳述します。

Rust製ネイティブNPMライブラリの設計

このセクションでは、Rustで実装するNode.jsネイティブアドオンの具体的な設計と、Electronアプリから使いやすくするための工夫について述べます。

Node-APIとnapi-rsの活用

Node.jsには「N-API」（Node API）と呼ばれる安定したCインターフェースがあり、ネイティブモジュールをNode.jsのバージョンに依存せずビルドできる仕組みがあります。N-APIを使うと、一度ビルドしたバイナリを将来のNode/Electronバージョンでもそのまま利用できる互換性が得られます ￼。Rustでネイティブアドオンを作る場合も、このN-APIを利用するのがベストプラクティスです。

特にnapi-rsというプロジェクトは、Node-APIのRustバインディングを提供しており、Rustコードから簡潔にNode.jsアドオンを作成できます ￼ ￼。napi-rsでは#[napi]属性マクロを関数や構造体に付与することで、自動的にNode.jsにエクスポートされる関数を定義できます。例えばRust側に以下のような関数を定義するとします:

#[napi]
pub fn copy_files(paths: Vec<String>) -> napi::Result<()> {
    // 受け取ったファイルパス一覧をOSごとのクリップボードにコピーする処理
    Ok(())
}

この関数をビルドしたネイティブモジュールからは、JavaScript側でaddon.copyFiles([...])のように呼び出せるようになります。napi-rsは内部でN-APIを用いているため、Electronが採用するNode.jsのABIに左右されず動作するのも利点です。 ￼

さらにnapi-rsには開発補助機能があり、上記のようなエクスポート関数のTypeScript型定義（.d.ts）を自動生成することも可能です ￼。実際、napi-rsのスタータープロジェクトではビルド時にindex.d.tsが生成され、Rust側で定義した関数シグネチャに対応するTypeScript型が出力されます ￼。これにより、利用者は手動で型定義を書くことなく、TypeScriptからネイティブ関数を安全に呼び出すことができます。

他の選択肢との比較: 以前からあるNeonフレームワーク（Rust用のNodeアドオン開発ツール）も検討できますが、Neonは独自構文やABI依存があったため、近年はnapi-rs（Node-APIベース）への移行が進んでいます。実際、napi-rsは人気のあるRust製ツール（例: SWCやOxidation関連プロジェクト）の中でも利用が増えており ￼ ￼、信頼性・将来性の点で適しています。

TypeScriptから利用するAPI設計

最終的なNPMパッケージとしては、Electronアプリ側からシンプルな関数を呼び出せる形にします。例えば、

// TypeScript側からの使用イメージ
import { copyFiles } from 'electron-multiclipboard';

await copyFiles(['C:\\path\\to\\image1.png', 'C:\\path\\to\\image2.jpg']);

のように、ファイルパスの配列を渡すだけでクリップボードにコピーできる関数を提供します。内部的には上記のRust実装（例: copy_files関数）に委ねますが、TypeScriptの型定義があることで開発者は使いやすくなります。Promiseを返す非同期関数として実装し、エラーハンドリング（例えばサポート外プラットフォームで呼ばれた場合のエラーや、クリップボード操作失敗時の例外）も適切に行います。

Node.jsネイティブモジュール（*.nodeファイル）は通常CommonJS形式でrequire()して使いますが、本ライブラリではESM（ECMAScript Modules）にも対応させたいです。方法としては、package.jsonに"type": "module"を指定しつつ、エクスポートにCJSとESMのエントリポイントを両立させることが考えられます。例えばexportsフィールドで"require"向けにはindex.cjs、"import"向けにはindex.mjsを指定し、index.mjs内でNodeネイティブモジュールを動的に読み込むというアプローチです。具体的には、ESM側では Node.js のimport.meta.urlからcreateRequireを使って.nodeモジュールを読み込むことで、ESMコードでも.nodeバイナリを利用できます ￼。これにより、従来のCommonJS環境と新しいESM環境の両方でシームレスにimport { copyFiles } from '...';が機能するようになります。

プロジェクト構成と技術スタック

開発効率とメンテナンス性を高めるため、プロジェクトはモノレポ構成とし、モダンなツールチェインを採用します。
	•	ディレクトリ構成: ひとつのGitリポジトリ内にRustクレートとNPMパッケージの構成を置きます。例えば、/crateディレクトリにCargo.tomlを配置してRustコードを実装し、/packageディレクトリにpackage.jsonやTypeScriptのラッパーコード（必要なら）を置く形です。小規模であればRustクレート自体をNPMパッケージルートに置き、Cargo.tomlとpackage.jsonを同階層に配置することも可能です（napi-rsのテンプレートはこの形です）。モノレポにすることでRustコードとTSコードを一元管理でき、将来的にプラットフォーム別モジュールや追加ツール（例えばCLI版）を同梱する際にも拡張が容易です。
	•	言語・ツール選定: Rustで核心のClipboard操作を実装し、TypeScriptで公開APIを整えます。コード品質の確保のため、Biomeなど最新の統合リンタ・フォーマッタを導入します。Biome（旧Rome）はRust製の高速なJS/TSツールであり、内部でOxcというパーサエンジンを使用しています ￼。Biomeを使うことでESLintとPrettier相当の機能を一括して適用でき、整然としたコードスタイルと確実な問題検出が期待できます。また、Rust側は標準のcargo fmtやcargo clippyでフォーマット・静的解析を行います。
	•	モジュール方式: 先述の通りESM対応をしつつ、CommonJSでも動作するハイブリッドNPMモジュールとします。Node.jsネイティブアドオンは.nodeバイナリを直接読み込むため、バンドラ（Webpackなど）でまとめることはせず、そのままパッケージに含めます。TypeScriptで書いたラッパー（必要であれば、例えば前述のESMローダなど）コードはtscでトランスパイルして含めます。TypeScriptの設定はmoduleResolution: node16などにして、exportsフィールド対応のパッケージ解決を正しく行えるよう調整します。
	•	依存関係: Rust側ではwindowsクレート（Windows API呼び出し用）やobjc/core-foundationクレート（macOS API用）、x11やclipboardクレート（Linux用）などを必要に応じて使います。ただ、複数プラットフォームのコードを含める場合は、Cargoの機能である条件付きコンパイル（cfg属性）を使い、#[cfg(target_os = "windows")]のようにしてOS別にコードを切り替える設計にします。一方、Node.js側から見ると依存パッケージはなく、ネイティブ依存はバイナリにパッケージングされる形となります（pure C++アドオンと同様）。

ビルドと配布の自動化

ネイティブモジュールの導入にはビルドの手間がつきものですが、本プロジェクトではNPMインストール時に自動ビルドもしくはバイナリ配布が行えるようにします。以下の二段構えのアプローチが考えられます。
	•	プリビルドバイナリの配布: ユーザがnpm installした際に、その環境（OS/CPU）に合った事前ビルド済みバイナリを取得する方法です。これは多くのネイティブライブラリで採用されている方式で、例えば@node-rs/...系列のパッケージでは、各プラットフォーム別にサブパッケージを発行し、メインのパッケージからoptionalDependencies経由で必要なものだけインストールさせる仕組みを使っています ￼ ￼。当プロジェクトでも、GitHub ActionsなどCI上でWindows・macOS・Linux向けにバイナリをビルドし、npmにmy-lib-win32, my-lib-darwinといったパッケージを公開、最終的に利用者はnpm install my-libするだけで適切なバイナリが入るようにできます。この方法のメリットは利用者がRustやビルドツールを用意しなくて良い点です。一方で、CI設定や各種プラットフォームでのテスト・ビルドアーティファクトのアップロード管理など、ライブラリ開発者側の負担は増えます。
	•	インストール時のローカルビルド: npmのprepareまたはpostinstallスクリプトでcargo buildを呼び出し、その場でコンパイルする方法です。npmスクリプト内でRustコンパイラを実行するため、ユーザ環境にRust（およびOS毎のビルドツールチェーン：WindowsならVisual C++ Build Tools、macOSならXcode CLIなど）がインストールされている必要があります。この方法は実装が簡単（package.jsonにビルドコマンドを書く程度）ですが、環境依存で失敗するリスクがあります。もしこの方式を採用する場合は、README等で必要なビルド環境（Rustのインストール方法やWindowsの場合のVisual Studio要件など）を明記し、npm install時にエラーメッセージも出るようにしておく配慮が必要です。

現状、Rust製のNodeアドオンでは前者のプリビルド配布が推奨傾向にあります ￼ ￼。特にエンドユーザにビルドさせるのはハードルが高いため、CIによるマルチプラットフォームビルドを整えるのが理想です。napi-rsのテンプレートプロジェクトでは、GitHub Actions上でNode 14/16/18 × Windows/Linux/macOSのビルド・テストを行い、成果物をnpmに公開するフローが用意されています ￼。これをベースにすれば、大部分の自動化は実現できます。

補足: Node-APIの採用により、仮にElectronのバージョンが変わってNode.js ABIが変化しても、N-APIレベルで安定していればバイナリの再ビルド不要で動作します ￼。これは配布面で大きな強みです。例えばElectron 22（Node.js v16相当）からElectron 24（Node.js v18相当）に上がった場合でも、同じN-APIバージョンをサポートしていれば再インストールの必要がありません（※Electron自体のChromiumアップデートでClipboard挙動が変わる可能性はありますが、その際もモジュールを更新すればよいでしょう）。

Electronアプリへの組み込みにおける考慮事項

最後に、完成したネイティブモジュールをElectronアプリに統合する際のポイントや注意点を整理します。
	•	Electronとネイティブアドオンの互換性: 上述のとおりN-APIを使っていればElectronのNode.jsバージョン差異を意識せずに済みます。とはいえElectronは独自にChromiumとNodeを組み合わせており、Electronのバージョン＝サポートするNode-APIバージョンにも注意が必要です。幸いNode-APIは後方互換が維持されており、たとえばNode-API v8対応でビルドしておけば、大抵の最新Electronで動作します。Electron公式も推奨するnode-addon-api（C++ラッパー）経由と同等の安定性がRust+napi-rsでも確保できます。
	•	パッケージングへの対応: Electronアプリを配布用にパッケージング（electron-builderやelectron-packager使用）する際、.nodeネイティブモジュールファイルの取り扱いに留意します。通常、.nodeファイルはASARアーカイブに含めず展開した状態で配置する必要があります。electron-builderの場合、自動的にnode_modules内のネイティブ拡張はasarアンパックされますが、念のためasarUnpackオプションで当該モジュールを指定しておくと安全です。また、インストール時に生成またはダウンロードしたバイナリが正しくパッケージに含まれるよう、filesやextraResources設定も確認します。
	•	メインプロセス vs レンダラープロセス: Electronでクリップボード操作を行う際、どのプロセスで実行するか検討が必要です。Electronのclipboardモジュール自体はメイン/レンダラーのどちらからでも使用可能（但しレンダラーではnodeIntegrationが必要）ですが、本モジュールはNodeネイティブアドオンなのでNode.js環境がある場所で動作します。典型的にはメインプロセスでIPC経由で呼び出す方法が堅実です。メインプロセスであればバックグラウンドでWin32 APIやmacOS APIを直接呼んでも問題ありません。一方、レンダラープロセスで使用する場合、最近のElectronではセキュリティ強化のためデフォルトでnodeIntegration: false（Nodeモジュール使用不可）になっていることに注意が必要です。必要ならプレロードスクリプトでcontextBridgeを通じて本機能をExposeし、UI側（ブラウザコンテキスト）から使えるようにします。
	•	権限と制約: クリップボードへの書き込みは通常追加の権限なしに可能ですが、OSによってはサンドボックス環境で制限がある場合があります。Electronアプリ自体はデスクトップアプリなので制約は緩いですが、例えばWindowsのUWP的な動作やmacOSのサンドボックスでは事情が変わる可能性があります。本モジュールに関して言えば、通常のElectronアプリで動作させる限り特別な許可ダイアログ等は不要です。ユーザー操作に伴ってコピー関数を呼ぶことで、UX的にも自然な振る舞いとなるでしょう。
	•	ネイティブリソース管理: クリップボードはグローバルな共有リソースであるため、OpenClipboardに失敗する（他のアプリが長時間掴んでいる）ケースや、コピーしたファイルが後で削除されてしまうケースなども考慮します。とはいえ、エクスプローラーからのコピーと同じ動作を再現するなら、基本的にはファイルパスだけを渡すのでファイル実体の存在確認は貼り付け側（OSやアプリ）に委ねられます。実装側では、Clipboardへのデータ設定後にGlobalFreeを呼ばない（所有権がOSに移るため）ことや、失敗時にメモリリークしないようにすることなど、低レベルAPIの正しい使い方を守ります ￼。
	•	性能: 操作自体は軽量ですが、巨大なファイルパスを何百件もコピーするとメモリブロックサイズが大きくなります。この点もOS標準の挙動と同じですので、大量のファイルコピーは一度に扱いきれない可能性があります（エクスプローラーでも数千ファイルのコピーは時間がかかる）。必要なら1度にコピーできる件数に上限を設けるなどの対策もドキュメント化します。

まとめと提案

以上の調査から、Electronアプリで複数画像ファイルをまとめてクリップボードにコピーし、他アプリへペーストできるようにするには、OSごとのネイティブ形式でクリップボードにファイルパスリストを設定する必要があり、そのためにはElectronからネイティブコードを呼び出す方法が現実的という結論に至りました。最も有望なアプローチはRustで実装したネイティブアドオンをNPMパッケージとして提供することです。

本提案では、Windows向けにまずCF_HDROP形式による複数ファイルコピー機能を実装し、次いでmacOS（NSPasteboardのwriteObjects）やLinux（text/uri-listの設定）にも対応拡張する方針を取ります。 ￼ ￼RustとNode-APIを用いることで、Electronとの互換性を保ちつつ高パフォーマンスなネイティブ処理が可能です。また、プロジェクトのセットアップにおいてはモダンな技術スタック（Rust・TypeScript・Biome・Oxcなど）を採用し、開発体験とコード品質の向上を図ります。

配布面では、GitHub Actions等を活用した自動ビルドと各プラットフォーム用バイナリの公開を行い、利用者が煩雑な環境構築をしなくても済むようにします。 ￼ ￼さらにElectronアプリ組み込み時のベストプラクティス（ネイティブモジュールのasar除外、IPCデザイン、型定義の提供等）をドキュメントで示すことで、開発者が安心して当該ライブラリを導入できるよう配慮します。

以上の計画により、ユーザーが求める「エクスプローラー/Finderからのコピー&ペーストと同じ体験」をElectronアプリ上で実現できると考えられます。今後は本提案に沿ってプロトタイプ実装を行い、動作検証と必要な調整を進めていくことを推奨します。

参考文献・情報源: 本報告書中で言及した技術仕様や方法については、Electronや各OSの公式ドキュメント、ならびに関連する開発者コミュニティの知見を参照しました。特に、WindowsのCF_HDROP形式についてはMicrosoftの開発者向け資料 ￼ ￼、macOSのNSPasteboard操作についてはAppleの開発者ドキュメントおよび実例 ￼ ￼、Linuxのクリップボード仕様についてはオープンソースコミュニティの情報 ￼を参考にしています。また、RustからNode.jsへの連携技術はnapi-rsプロジェクトの資料 ￼ ￼や同プロジェクトのテンプレートコード ￼ ￼を、大規模プロジェクトにおけるモダンツールの活用例はRome/BiomeやOxcに関する記事 ￼などを参考にしました。以下に主要な出典を示します。

参考資料:
	•	Electron Clipboard API制限に関する議論（GitHub issue） ￼
	•	WindowsにおけるCF_HDROP仕様（Microsoft Docs） ￼ ￼
	•	WindowsでのCF_HDROP実装例（コード例） ￼
	•	macOSでのNSPasteboardへの複数ファイル書き込み例 ￼ ￼
	•	Linux X11/Waylandでのtext/uri-list使用例 ￼
	•	PowerShellを用いたファイルパスコピーの提案（Stack Overflow） ￼
	•	napi-rsを使ったNodeアドオン開発解説（Dev.to記事） ￼ ￼
	•	napi-rsテンプレートのCI/配布に関する記述 ￼ ￼
	•	Node-APIを用いたマルチプラットフォーム配布方法 ￼ ￼
	•	BiomeやOxcなどRust製JSツールについての言及 ￼