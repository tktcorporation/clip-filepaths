name: PR Build Check

permissions:
  contents: read

on:
  pull_request:
    branches:
      - main
    # paths:
    #   - 'src/**'
    #   - 'native/**'
    #   - 'npm/**'
    #   - 'package.json'
    #   - 'pnpm-lock.yaml'
    #   - 'Cargo.toml'
    #   - 'Cargo.lock'

jobs:
  # 各プラットフォーム向けのバイナリをビルド
  build-binaries:
    name: バイナリビルド (${{ matrix.name }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false  # 一つのビルドが失敗しても他を続行
      matrix:
        include:
          - name: linux-x64-gnu # napi naming convention
            os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            # use-cross: true # Removed
          - name: linux-arm64-gnu # napi naming convention
            os: ubuntu-latest
            target: aarch64-unknown-linux-gnu
            # use-cross: true # Removed
          - name: darwin-x64 # napi naming convention
            os: macos-latest
            target: x86_64-apple-darwin
            # use-cross: false # Removed
            # setup-script: "rustup target add x86_64-apple-darwin" # Removed
          - name: darwin-arm64 # napi naming convention
            os: macos-latest
            target: aarch64-apple-darwin
            # use-cross: false # Removed
            # setup-script: "rustup target add aarch64-apple-darwin" # Removed
          - name: win32-x64-msvc # napi naming convention
            os: windows-latest
            target: x86_64-pc-windows-msvc
            # use-cross: false # Removed
            # setup-script: "" # Removed

    steps:
      - uses: actions/checkout@v3
      
      - name: Rustツールチェインのセットアップ
        uses: actions-rs/toolchain@v1
        with:
          profile: minimal
          toolchain: stable
          override: true

      - name: Rustターゲットの追加
        run: rustup target add ${{ matrix.target }}

      - name: Node.js設定
        uses: ./.github/actions/node-setup
        with:
          node-version: ''
          package-path: '.'
      
      - name: Dockerセットアップ (Linux QEMU用)
        # if: ${{ matrix.use-cross }} # Removed, now based on OS
        if: startsWith(matrix.os, 'ubuntu')
        uses: docker/setup-buildx-action@v2

      - name: QEMUセットアップ (Linuxのみ)
        if: startsWith(matrix.os, 'ubuntu')
        uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64 # Build ARM64 on x64 host

      - name: Linux 依存関係のインストールと設定
        if: startsWith(matrix.os, 'ubuntu')
        shell: bash
        run: |
          sudo apt-get update -y
          if [[ "${{ matrix.target }}" == "aarch64-unknown-linux-gnu" ]]; then
            echo "Configuring APT and installing dependencies for ARM64 cross-compilation..."
            # Add the Ubuntu Ports repository which contains arm64 packages
            PORTS_LIST=/etc/apt/sources.list.d/ubuntu-ports.list
            echo "deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports noble main restricted universe multiverse" | sudo tee $PORTS_LIST
            echo "deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports noble-updates main restricted universe multiverse" | sudo tee -a $PORTS_LIST
            echo "deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports noble-backports main restricted universe multiverse" | sudo tee -a $PORTS_LIST
            echo "deb [arch=arm64] http://ports.ubuntu.com/ubuntu-ports noble-security main restricted universe multiverse" | sudo tee -a $PORTS_LIST

            # Add arm64 architecture
            sudo dpkg --add-architecture arm64

            # Update package lists (should now find arm64 packages from ports)
            sudo apt-get update -y

            # Now install the arm64 packages
            sudo apt-get install -y --no-install-recommends \
              gcc-aarch64-linux-gnu \
              g++-aarch64-linux-gnu \
              pkg-config-aarch64-linux-gnu \
              libx11-dev:arm64 \
              libxtst-dev:arm64 \
              libdbus-1-dev:arm64 # electron-rs/cargo-build requires this
            # Configure pkg-config for cross-compilation
            export PKG_CONFIG_PATH=/usr/lib/aarch64-linux-gnu/pkgconfig
            export PKG_CONFIG_ALLOW_CROSS=1
            export CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc
            echo "PKG_CONFIG_PATH=$PKG_CONFIG_PATH" >> $GITHUB_ENV
            echo "PKG_CONFIG_ALLOW_CROSS=1" >> $GITHUB_ENV
            echo "CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc" >> $GITHUB_ENV
          elif [[ "${{ matrix.target }}" == "x86_64-unknown-linux-gnu" ]]; then
            echo "Installing dependencies for x86_64 native compilation..."
            sudo apt-get install -y --no-install-recommends \
              pkg-config \
              libx11-dev \
              libxtst-dev \
              libdbus-1-dev # electron-rs/cargo-build requires this
          fi

      - name: napi-rs CLI セットアップ # Renamed and removed condition
        # if: ${{ !matrix.use-cross }} # Removed condition
        shell: bash
        run: npm install -g @napi-rs/cli

      - name: バイナリビルド (napi build) # Renamed and removed condition
        # if: ${{ !matrix.use-cross }} # Removed condition
        shell: bash
        run: |
          set -ex
          # Use appropriate command based on OS and target for potential QEMU usage
          # Environment variables for cross-compilation (like PKG_CONFIG_PATH) are set in the previous step for Linux
          # if [[ "${{ matrix.os }}" == "ubuntu-latest" && "${{ matrix.target }}" == "aarch64-unknown-linux-gnu" ]]; then
          #   # Explicitly use cross-compilation features if needed, napi might handle this automatically
          #   echo "Building for linux-arm64 on x64 host..."
          #   # napi build might automatically use QEMU if set up
          #   napi build --platform --release --target ${{ matrix.target }}
          # elif [[ "${{ matrix.os }}" == "ubuntu-latest" && "${{ matrix.target }}" == "x86_64-unknown-linux-gnu" ]]; then
          #    echo "Building for linux-x64 natively..."
          #    napi build --platform --release --target ${{ matrix.target }}
          # else
          #    # macOS and Windows build as before
          #    napi build --platform --release --target ${{ matrix.target }}
          # fi
          # Simpler approach: let napi/cargo handle it with the correct env vars set
          echo "Running napi build for target: ${{ matrix.target }}"
          napi build --platform --release --target ${{ matrix.target }}

      - name: 成果物移動 (.node) # Renamed and removed condition
        # if: ${{ !matrix.use-cross }} # Removed condition
        shell: bash
        run: |
          set -e
          TARGET_DIR="target/${{ matrix.target }}/release"
          mkdir -p "$TARGET_DIR"
          # napi build はルートに .node を出力する場合があるため検索
          NODE_FILE=$(find . -maxdepth 1 -name "electron-pan-clip.*.node" -print -quit)
          if [[ -n "$NODE_FILE" ]]; then
            echo "Moving $NODE_FILE to $TARGET_DIR"
            mv "$NODE_FILE" "$TARGET_DIR/"
          else
            # napi build が直接 target/.../release に出力する可能性も考慮
            NODE_FILE_IN_TARGET=$(find "$TARGET_DIR" -name "electron-pan-clip.*.node" -print -quit)
            if [[ -z "$NODE_FILE_IN_TARGET" ]]; then
               echo "Error: No .node file found after napi build in root or $TARGET_DIR!"
               echo "Listing current directory:"
               ls -la .
               echo "Listing target directory ($TARGET_DIR):"
               ls -la "$TARGET_DIR" || echo "$TARGET_DIR not found or empty"
               exit 1
            fi
            echo ".node file already exists in $TARGET_DIR, no move needed."
          fi
      
      # --- 共通ステップ --- 
      - name: 成果物を収集
        shell: bash
        run: |
          ARTIFACT_DIR="artifacts/pr-binaries-${{ matrix.name }}"
          mkdir -p "$ARTIFACT_DIR"
          TARGET_RELEASE_DIR="target/${{ matrix.target }}/release"
          # matrix.name (例: linux-x64-gnu) を使って期待するファイル名を生成
          EXPECTED_NODE_FILENAME="electron-pan-clip.${{ matrix.name }}.node"

          echo "Target release directory: $TARGET_RELEASE_DIR"
          echo "Artifact directory: $ARTIFACT_DIR"
          echo "Expected node filename: $EXPECTED_NODE_FILENAME"
          echo "Listing contents of $TARGET_RELEASE_DIR:"
          ls -la "$TARGET_RELEASE_DIR" || echo "Directory not found or empty"

          echo "Searching for .node file (napi build)..."
          # find で期待されるファイル名を直接探す方が確実かもしれない
          NODE_FILE=$(find "$TARGET_RELEASE_DIR" -maxdepth 1 -name "$EXPECTED_NODE_FILENAME" -print -quit)

          if [[ -n "$NODE_FILE" ]]; then
            echo "Found node file: $NODE_FILE"
            echo "Copying $NODE_FILE to $ARTIFACT_DIR/"
            cp "$NODE_FILE" "$ARTIFACT_DIR/"
          else
            # 念のため、パターンマッチでも探してみる (napi build の出力名が微妙に違う可能性)
            NODE_FILE_PATTERN=$(find "$TARGET_RELEASE_DIR" -maxdepth 1 -name "electron-pan-clip.*.node" -print -quit)
            if [[ -n "$NODE_FILE_PATTERN" ]]; then
              echo "Found node file with pattern: $NODE_FILE_PATTERN"
              echo "Copying $NODE_FILE_PATTERN to $ARTIFACT_DIR/$EXPECTED_NODE_FILENAME" # Rename to expected name
              cp "$NODE_FILE_PATTERN" "$ARTIFACT_DIR/$EXPECTED_NODE_FILENAME"
            else
               echo "Error: No .node file found matching '$EXPECTED_NODE_FILENAME' or pattern 'electron-pan-clip.*.node' in $TARGET_RELEASE_DIR for napi build!"
               # Add more debugging info
               echo "Listing current directory:"
               ls -la .
               echo "Listing target directory ($TARGET_RELEASE_DIR):"
               ls -la "$TARGET_RELEASE_DIR" || echo "$TARGET_RELEASE_DIR not found or empty"
               exit 1
            fi
          fi

      - name: 成果物をアップロード
        uses: actions/upload-artifact@v4
        with:
          name: pr-binaries-${{ matrix.name }}
          path: artifacts/pr-binaries-${{ matrix.name }}
  
  # ビルド結果の検証
  verify-binaries:
    name: バイナリ検証
    needs: build-binaries
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Node.js設定
        uses: ./.github/actions/node-setup
        with:
          node-version: ''
          package-path: '.'
      
      # ビルド成果物をダウンロード
      - name: 成果物をダウンロード
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          pattern: pr-binaries-*
      
      # 成果物を正しい場所にコピー
      - name: 成果物を配置
        shell: bash
        run: |
          mkdir -p npm/linux-x64-gnu npm/linux-arm64-gnu npm/darwin-x64 npm/darwin-arm64 npm/win32-x64-msvc
          
          # Linux x64
          find artifacts -name "electron-pan-clip.linux-x64-gnu.node" -exec cp {} npm/linux-x64-gnu/ \; || echo "Warning: linux-x64-gnu バイナリが見つかりませんでした"
          
          # Linux ARM64
          find artifacts -name "electron-pan-clip.linux-arm64-gnu.node" -exec cp {} npm/linux-arm64-gnu/ \; || echo "Warning: linux-arm64-gnu バイナリが見つかりませんでした"
          
          # macOS x64
          find artifacts -name "electron-pan-clip.darwin-x64.node" -exec cp {} npm/darwin-x64/ \; || echo "Warning: darwin-x64 バイナリが見つかりませんでした"
          
          # macOS ARM64
          find artifacts -name "electron-pan-clip.darwin-arm64.node" -exec cp {} npm/darwin-arm64/ \; || echo "Warning: darwin-arm64 バイナリが見つかりませんでした"
          
          # Windows x64
          find artifacts -name "electron-pan-clip.win32-x64-msvc.node" -exec cp {} npm/win32-x64-msvc/ \; || echo "Warning: win32-x64-msvc バイナリが見つかりませんでした"
          
          # 成果物の確認
          find npm -type f | sort
      
      # バイナリ検証
      - name: バイナリ検証
        run: |
          FOUND_COUNT=$(find npm -type f -name "*.node" | wc -l)
          echo "見つかったバイナリ数: $FOUND_COUNT"
          if [ $FOUND_COUNT -eq 0 ]; then
            echo "エラー: バイナリが1つも見つかりません！"
            exit 1
          fi
          node scripts/verify-binaries.js || {
            echo "警告: バイナリ検証で一部問題が見つかりました"
            exit 1
          } 